/*
  This class has been generated by the Code Generator
*/

package com.opentext.apps.cc.upgradeutils;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.StringReader;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Base64;
import java.util.Collection;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

import com.cordys.cpc.bsf.busobject.BSF;
import com.cordys.cpc.bsf.busobject.BusObjectConfig;
import com.cordys.cpc.bsf.soap.SOAPRequestObject;
import com.eibus.util.logger.CordysLogger;
import com.eibus.util.logger.Severity;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.opentext.apps.cc.upgradeutils.dao.CCUpgradeUtilsDao;
import com.opentext.apps.cc.upgradeutils.model.FieldModel;
import com.opentext.apps.cc.upgradeutils.util.FileUtil;
import com.opentext.apps.cc.upgradeutils.util.NomUpgradeUtil;
import com.opentext.apps.cc.upgradeutils.util.NomUtil;
import com.opentext.apps.cc.upgradeutils.util.SearchQueryUtil;
import com.opentext.apps.cc.upgradeutils.util.WorkBookManager;
import com.opentext.apps.cc.upgradeutils.util.WorkBookManagerImpl;

public class CCUpgradeUtils extends CCUpgradeUtilsBase {
	private static final CordysLogger logger = CordysLogger.getCordysLogger(CCUpgradeUtils.class);

	public CCUpgradeUtils() {
		this((BusObjectConfig) null);
	}

	public CCUpgradeUtils(BusObjectConfig config) {
		super(config);
	}

	public static String downloadUpgradeErrorReport(String jobId) {
		if (Objects.isNull(jobId)) {
			return "NO_REPORT_AVAILABLE";
		}
		byte[] fileContent = generateErrorReports(getUpgradeJobErrorRecords(jobId));
		return Base64.getEncoder().encodeToString(fileContent);
	}

	private static Map<String, List<Map<String, String>>> getUpgradeJobErrorRecords(String jobId) {
		Map<String, List<Map<String, String>>> sheetData = new LinkedHashMap<>();
		SOAPRequestObject updateProcess = new SOAPRequestObject(
				"http://schemas/OpentextUpgradeUtility/UpgradeBatchJob/operations", "getAllRelatedUpgradeBatchJobs",
				null, null);
		updateProcess.addParameterAsXml(NomUtil.parseXML("<parentJobId>" + jobId + "</parentJobId>"));
		updateProcess.addParameterAsXml(NomUtil.parseXML("<entityType>CONTRACT</entityType>"));
		updateProcess.addParameterAsXml(NomUtil.parseXML("<jobStatus>ERROR</jobStatus>"));
		int updateProcessResponse = updateProcess.sendAndWait();
		int[] nodes = NomUtil.getNodeList(".//UpgradeBatchJob", updateProcessResponse);
		List<Map<String, String>> jobRecords = new LinkedList<Map<String, String>>();
		for (int i : nodes) {
			String AllInstanceIds = null, JobStatus = null, SuccessIds = null, ErrorJson = null,
					UpgradeBatchJobId = null, ParentJobId = null;
			UpgradeBatchJobId = com.eibus.xml.nom.Node
					.getDataWithDefault(NomUtil.getNode(".//UpgradeBatchJob-id//Id", i), null);
			ParentJobId = com.eibus.xml.nom.Node
					.getDataWithDefault(NomUtil.getNode(".//RelatedJob//UpgradeJob-id//Id", i), null);
			AllInstanceIds = com.eibus.xml.nom.Node.getDataWithDefault(NomUtil.getNode(".//AllInstanceIds", i), null);
			JobStatus = com.eibus.xml.nom.Node.getDataWithDefault(NomUtil.getNode(".//ImportStatus", i), null);
			SuccessIds = com.eibus.xml.nom.Node.getDataWithDefault(NomUtil.getNode(".//LogDetails", i), null);
			ErrorJson = com.eibus.xml.nom.Node.getDataWithDefault(NomUtil.getNode(".//ErrorJson", i), null);
			jobRecords.addAll((populateErrorInstanceRecords(UpgradeBatchJobId, ParentJobId, AllInstanceIds, JobStatus,
					SuccessIds, ErrorJson)));
		}
		sheetData.put("ErrorReport", jobRecords);
		return sheetData;
	}

	@SuppressWarnings("unchecked")
	private static List<Map<String, String>> populateErrorInstanceRecords(final String upgradeBatchJobId,
			String parentJobId, String allInstanceIds, String jobStatus, String successIds, String errorJson) {
		List<Map<String, String>> errorMapList = new LinkedList<>();
		String[] instaceArr = allInstanceIds.split(";");
		if (instaceArr.length > 0) {
			Arrays.asList(instaceArr).forEach(inst -> {
				Map<String, String> errorMap = new LinkedHashMap<>();
				if (null != inst && !inst.isEmpty()) {
					String status = "";
					String message = "";
					String errorJsonStr = "{}";
					if (null != errorJson && !errorJson.trim().isEmpty()) {
						errorJsonStr = errorJson;
					}
					ObjectMapper objectMapper = new ObjectMapper();
					Map<String, Object> treeMap = null;
					try {
						treeMap = objectMapper.readValue(errorJsonStr, Map.class);
					} catch (JsonProcessingException e) {
						logger._log("com.opentext.apps.cc.upgradeutils.CCUpgradeUtils", Severity.ERROR, e,
								"Error while executing populateErrorInstanceRecords");
					}
					if (null != treeMap && treeMap.containsKey(inst)) {
						Object instanceObj = treeMap.get(inst);
						if (instanceObj instanceof Map<?, ?>) {
							Map<String, Object> instMap = (Map<String, Object>) treeMap.get(inst);
							message = instMap.get("Errors").toString();
						}
						status = "ERROR";
						errorMap.put("Batch job id", upgradeBatchJobId);
						errorMap.put("Job id ", parentJobId);
						errorMap.put("InstanceId", inst);
						errorMap.put("JobStatus", status);
						errorMap.put("Error", message);
						errorMapList.add(errorMap);
					}
				}
			});
		}
		return errorMapList;
	}

	protected static byte[] generateErrorReports(Map<String, List<Map<String, String>>> reportData) {
		String orgDN = BSF.getOrganization();
		String orgName = orgDN.substring(orgDN.indexOf('=') + 1, orgDN.indexOf(','));
		ByteArrayOutputStream bos = null;
		if (Objects.nonNull(reportData) && !reportData.isEmpty()) {
			try {
				String filePath = FileUtil.getDownloadReadPath() + orgName + File.separator + "upgradeReport"
						+ File.separator + "upgradeErrorReportGen.xlsx";
				WorkBookManager wbManager = new WorkBookManagerImpl(Paths.get(filePath));
				final Workbook wb = wbManager.getWorkBook();
				for (String sheetName : reportData.keySet()) {
					List<Map<String, String>> sheetData = reportData.get(sheetName);
					if (Objects.nonNull(sheetData) && !sheetData.isEmpty()) {
						Collection<String> columns = sheetData.iterator().next().keySet();
						Sheet sheet = wbManager.createSheet(sheetName);
						wbManager.createRow(sheet, columns, wbManager.createHeaderStyle(wb), 0);
						int rowIndex = 1;
						Iterator<Map<String, String>> rows = sheetData.iterator();
						while (rows.hasNext()) {
							Collection<String> rowData = rows.next().values();
							wbManager.createRow(sheet, rowData, null, rowIndex++);
						}
					}
				}
				bos = new ByteArrayOutputStream();
				wb.write(bos);
			} catch (IOException e) {
				logger._log("com.opentext.apps.cc.upgradeutils.CCUpgradeUtils", Severity.ERROR, e,
						"Error while executing generateErrorReports");
			}
		}
		if (null != bos) {
			return bos.toByteArray();
		} else {
			return null;
		}

	}

	public static String appendContractIds(String contracts) {
		DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
		DocumentBuilder db;
		StringBuffer buffer = new StringBuffer();
		try {
			db = dbf.newDocumentBuilder();
			Document doc = db.parse(new InputSource(new StringReader(contracts)));
			doc.getDocumentElement().normalize();
//			System.out.println(doc.toString());
//			System.out.println(doc.getNodeValue());
			NodeList nodeList = doc.getChildNodes().item(0).getChildNodes();
			for (int itr = 0; itr < nodeList.getLength(); itr++) {
				Node node = nodeList.item(itr);
				if (node.getNodeType() == Node.ELEMENT_NODE && node.getNodeName().contains("Contract")) {
					String nodeId = nodeList.item(itr).getFirstChild().getFirstChild().getTextContent().trim();
					buffer.append(nodeId + ";");
				}
			}
		} catch (ParserConfigurationException | SAXException | IOException e) {
//			e.printStackTrace();
			logger._log("com.opentext.apps.cc.upgradeutils.CCUpgradeUtils", Severity.ERROR, e,
					"Error while executing appendContractIds");
		}
		return buffer.toString();
	}

	public static String appendIds(String path, int datanode) {
		if (null == path) {
			return "";
		}
		int[] nodes = NomUtil.getNodeList(path, datanode);
		StringBuffer buffer = new StringBuffer();
		for (int itr = 0; itr < nodes.length; itr++) {
			String nodeId = NomUtil.getData(nodes[itr]);
			buffer.append(nodeId + ";");
		}
		return buffer.toString();
	}

	public static void getCCUpgradeUtilsObjects(String fromVersion) {
		// TODO implement body
	}

	public static String getCCToVersion(String fromVersion) {
		String toVersion = null;
		ReadXmlFile.readXmlFile();
		Node node = ReadXmlFile.getLastNodeList();
		if (null != node) {
			Element eElement = (Element) node;
			toVersion = eElement.getElementsByTagName(ReadXmlFile.VERSION).item(0).getTextContent();
		}
		return toVersion;
	}

	@SuppressWarnings("unchecked")
	public static int getContractIdNodes(String contracts, String errorJson) {

		int contractIdsNode = 0;
		StringBuffer buffer = new StringBuffer();
		if (null != contracts && !"".equals(contracts)) {
			List<String> contractIdsList = Arrays.asList(contracts.split(";"));
			if (null != contractIdsList) {
				for (int i = 0; i < contractIdsList.size(); i++) {
					buffer.append("<Id>" + contractIdsList.get(i) + "</Id>");
				}
			}
		} else {
			if (null == errorJson || errorJson.trim().isEmpty()) {
				errorJson = "{}";
			}
			ObjectMapper objectMapper = new ObjectMapper();
			try {
				Map<String, Object> treeMap = objectMapper.readValue(errorJson, Map.class);
				if (null != treeMap && !treeMap.isEmpty()) {
					treeMap.forEach((key, value) -> {
						if (null != key && !"".equals(key)) {
							buffer.append("<Id>" + key + "</Id>");
						}
					});
				}

			} catch (JsonProcessingException e) {
//				e.printStackTrace();
				logger._log("com.opentext.apps.cc.upgradeutils.CCUpgradeUtils", Severity.ERROR, e,
						"Error while executing getContractIdNodes");
			}
		}
		contractIdsNode = NomUpgradeUtil.parseXML("<Ids>" + buffer.toString() + "</Ids>");

		return contractIdsNode;

	}

	@SuppressWarnings({ "unchecked", "rawtypes" })
	public static boolean checkContractFailed(String contractId, String featureName, String errorJson) {

		if (null == errorJson || errorJson.trim().isEmpty()) {
			errorJson = "{}";
		}
		ObjectMapper objectMapper = new ObjectMapper();
		try {
			Map<String, Object> treeMap = objectMapper.readValue(errorJson, Map.class);
			if (null != treeMap && !treeMap.isEmpty()) {
				if (treeMap.containsKey(contractId)) {
					Map<String, Object> valMap = (LinkedHashMap) treeMap.get(contractId);
					Object errors = valMap.get("Errors");
					if (null != errors && errors instanceof LinkedHashMap) {
						Map<String, Object> errorMap = (LinkedHashMap) errors;
						Set<String> errorFeatures = errorMap.keySet();
						if (errorFeatures.contains(featureName)) {
							return true;
						}
//						System.out.println(errorFeatures);
					}
				}
			}
		} catch (JsonProcessingException e) {
//			e.printStackTrace();
			logger._log("com.opentext.apps.cc.upgradeutils.CCUpgradeUtils", Severity.ERROR, e,
					"Error while executing checkContractFailed");
		}

		return false;
	}

	public static int getUpgradeVersionMetadata(String fromVersion, String toVersion, String entityType) {
		int relatedDepartmentsRecordNode = 0;
		ReadXmlFile.readXmlFile();
		Map<String, List<String>> bpmsVesrionMap = ReadXmlFile.getBPMsList(
				null != entityType ? entityType.toLowerCase() : ReadXmlFile.BPM_CONTRACT, fromVersion, toVersion);
		StringBuffer buffer = new StringBuffer();
		if (null != bpmsVesrionMap && bpmsVesrionMap.size() > 0) {
			List<String> value = null;
			for (String key : bpmsVesrionMap.keySet()) {
				value = bpmsVesrionMap.get(key);
				for (int i = 0; i < value.size(); i++) {
					buffer.append("<Bpm><Name>" + value.get(i) + "</Name><Version>" + key + "</Version></Bpm>");
				}
			}
			relatedDepartmentsRecordNode = NomUpgradeUtil.parseXML("<Bpms>" + buffer.toString() + "</Bpms>");
		}
		return relatedDepartmentsRecordNode;
	}

	public static int getUpgradeVersionTypeMetadata(String fromVersion, String toVersion, String entityType) {
		int relatedDepartmentsRecordNode = 0;
		ReadXmlFile.readXmlFile();
		Map<String, List<String>> bpmsVesrionMap = ReadXmlFile.getBPMsList(entityType, fromVersion, toVersion);
		StringBuffer buffer = new StringBuffer();
		if (null != bpmsVesrionMap && bpmsVesrionMap.size() > 0) {
			List<String> value = null;
			for (String key : bpmsVesrionMap.keySet()) {
				value = bpmsVesrionMap.get(key);
				for (int i = 0; i < value.size(); i++) {
					buffer.append("<Bpm><Name>" + value.get(i) + "</Name><Version>" + key + "</Version></Bpm>");
				}
			}
			relatedDepartmentsRecordNode = NomUpgradeUtil.parseXML("<Bpms>" + buffer.toString() + "</Bpms>");
		}
		return relatedDepartmentsRecordNode;
	}

//	java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String
	public static String addErrorToErrorJson(String errorJson, String instanceId, String feature, String version,
			String error) {
		if (null == errorJson || errorJson.trim().isEmpty()) {
			errorJson = "{}";
		}
		ObjectMapper objectMapper = new ObjectMapper();
		JsonNode jsonNode = null, jsonInstanceNode = null, jsonErrorNode = null, errorFeatureNode = null,
				errorInfoNode = null;
		String resultJson = null;
		try {
			jsonNode = objectMapper.readTree(errorJson);
			jsonInstanceNode = jsonNode.get(instanceId);
			if (null != jsonInstanceNode && !jsonInstanceNode.isEmpty()) {
				errorFeatureNode = jsonInstanceNode.get("Errors");
				errorInfoNode = objectMapper.createObjectNode();
				((ObjectNode) errorInfoNode).put("error", error);
				((ObjectNode) errorInfoNode).put("version", version);
				((ObjectNode) errorFeatureNode).set(feature, errorInfoNode);
			} else {
				jsonErrorNode = objectMapper.createObjectNode();
				errorFeatureNode = objectMapper.createObjectNode();
				errorInfoNode = objectMapper.createObjectNode();
				((ObjectNode) errorInfoNode).put("error", error);
				((ObjectNode) errorInfoNode).put("version", version);
				((ObjectNode) errorFeatureNode).set(feature, errorInfoNode);
				((ObjectNode) jsonErrorNode).set("Errors", errorFeatureNode);
				((ObjectNode) jsonNode).set(instanceId, jsonErrorNode);
			}
			resultJson = jsonNode.toString();
		} catch (JsonProcessingException e) {
//			e.printStackTrace();
			logger._log("com.opentext.apps.cc.upgradeutils.CCUpgradeUtils", Severity.ERROR, e,
					"Error while executing addErrorToErrorJson");
		}
		return resultJson;
	}

	public void onInsert() {
	}

	public void onUpdate() {
	}

	public void onDelete() {
	}

	public static String getContractsJSON() {
		CCUpgradeUtilsDao ccUpgradeUtilsDao = new CCUpgradeUtilsDao();
		return ccUpgradeUtilsDao.getContractObjects("");
	}

	public static String getContractsJSONFilters(int inRequest) {
		int[] fieldNodes = NomUtil.getNodeList(".//fields", inRequest);
		List<FieldModel> fieldModels = new ArrayList<>();
		for (int i : fieldNodes) {
//			String data = NomUtil.getData(".//", i);
			fieldModels.add(populateFieldModel(i));
		}
		SearchQueryUtil searchQueryUtil = new SearchQueryUtil();
		String sql = searchQueryUtil.prepareSelectQuery(fieldModels);

//		String str = NomUpgradeUtil.writeToString(inRequest);
		CCUpgradeUtilsDao ccUpgradeUtilsDao = new CCUpgradeUtilsDao();
		return ccUpgradeUtilsDao.getContractObjects(sql);
	}

	private static FieldModel populateFieldModel(int node) {
		String fieldName = NomUtil.getData(".//fieldName", node);
		String fieldDisplayName = NomUtil.getData(".//fieldDisplayName", node);
		String operator = NomUtil.getData(".//operator", node);
		String value = NomUtil.getData(".//value", node);
		return new FieldModel(fieldName, fieldDisplayName, "", operator, value);
	}

}
